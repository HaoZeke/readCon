/*
 * TestConFrame.cc
 *
 *  Created on: 23 July 2024
 *      Author: Rohit Goswami
 *     Company: University of Iceland
 */

#include "../include/ReadCon.hpp"
#include <gtest/gtest.h>

using namespace yodecon::types;

TEST(AtomDatumTest, Constructor) {
  AtomDatum atom("O", 1.0, 2.0, 3.0, false, 1);
  EXPECT_EQ("O", atom.symbol);
  EXPECT_DOUBLE_EQ(1.0, atom.x);
  EXPECT_DOUBLE_EQ(2.0, atom.y);
  EXPECT_DOUBLE_EQ(3.0, atom.z);
  EXPECT_EQ(false, atom.is_fixed);
  EXPECT_EQ(1, atom.atom_id);
}

TEST(ConFrameTest, Constructor) {
  ConFrame conFrame;
  conFrame.prebox_header = {"Generated by eOn", ""};
  conFrame.boxl = {25.0, 25.0, 25.0};
  conFrame.angles = {90.0, 90.0, 90.0};
  conFrame.postbox_header = {"", ""};
  conFrame.natm_types = 4;
  conFrame.natms_per_type = {2, 4, 6, 1};
  conFrame.masses_per_type = {15.99, 12.011, 1.008, 32.065};
  AtomDatum atom("O", 10.477713, 12.379463, 12.871778, false, 1);
  conFrame.atom_data.push_back(atom);

  EXPECT_EQ("Generated by eOn", conFrame.prebox_header[0]);
  EXPECT_DOUBLE_EQ(25.0, conFrame.boxl[0]);
  EXPECT_DOUBLE_EQ(90.0, conFrame.angles[0]);
  EXPECT_EQ(4, conFrame.natm_types);
  EXPECT_EQ(2, conFrame.natms_per_type[0]);
  EXPECT_DOUBLE_EQ(15.99, conFrame.masses_per_type[0]);
  EXPECT_EQ("O", conFrame.atom_data[0].symbol);
}

TEST(ConFrameTest, AtomicSymbolsRoundTrip) {
  // Create a ConFrame with multiple AtomDatum objects.
  ConFrame conFrame;
  conFrame.atom_data.push_back(AtomDatum("H", 1.0, 2.0, 3.0, false, 1));
  conFrame.atom_data.push_back(AtomDatum("C", 4.0, 5.0, 6.0, false, 2));
  conFrame.atom_data.push_back(AtomDatum("O", 7.0, 8.0, 9.0, false, 3));

  // Extract atomic symbols from ConFrame.
  std::vector<std::string> atomicSymbols;
  for (const auto &atom : conFrame.atom_data) {
    atomicSymbols.push_back(atom.symbol);
  }

  // Convert atomic symbols to numbers.
  std::vector<size_t> atomicNumbers =
      yodecon::symbols_to_atomic_numbers(atomicSymbols);

  // Check that the conversion was correct.
  ASSERT_EQ(atomicNumbers.size(), 3);
  EXPECT_EQ(atomicNumbers[0], 1); // H
  EXPECT_EQ(atomicNumbers[1], 6); // C
  EXPECT_EQ(atomicNumbers[2], 8); // O

  // Convert atomic numbers back to symbols.
  std::vector<std::string> roundTripSymbols =
      yodecon::atomic_numbers_to_symbols(atomicNumbers);

  // Check that the conversion back to symbols was correct.
  ASSERT_EQ(roundTripSymbols.size(), 3);
  EXPECT_EQ(roundTripSymbols[0], "H");
  EXPECT_EQ(roundTripSymbols[1], "C");
  EXPECT_EQ(roundTripSymbols[2], "O");
}

TEST(ConFrameTest, CreateSingleCon_SingleFile) {
  // The actual lines of the single con file.
  std::vector<std::string> a_fconts = {
      "Random Number Seed",
      "Time",
      "15.345600\t21.702000\t100.000000",
      "90.000000\t90.000000\t90.000000",
      "0 0",
      "218 0 1",
      "2",
      "2 2",
      "63.546000 1.007930",
      "Cu",
      "Coordinates of Component 1",
      "0.63940000000000108    0.90450000000000019    6.97529999999999539 1    "
      "0",
      "3.19699999999999873    0.90450000000000019    6.97529999999999539 1    "
      "1",
      "H",
      "Coordinates of Component 2",
      "8.68229999999999968    9.94699999999999740   11.73299999999999343 0  2",
      "7.94209999999999550    9.94699999999999740   11.73299999999999343 0  3"};

  // Call the function under test.
  ConFrame result = yodecon::create_single_con(a_fconts);
  // Check the resulting ConFrame object against expected values.
  ASSERT_EQ(result.prebox_header[0], "Random Number Seed");
  ASSERT_EQ(result.prebox_header[1], "Time");

  ASSERT_EQ(result.boxl[0], 15.345600);
  ASSERT_EQ(result.boxl[1], 21.702000);
  ASSERT_EQ(result.boxl[2], 100.000000);

  ASSERT_EQ(result.angles[0], 90.000000);
  ASSERT_EQ(result.angles[1], 90.000000);
  ASSERT_EQ(result.angles[2], 90.000000);

  ASSERT_EQ(result.natm_types, 2);
  ASSERT_EQ(result.natms_per_type[0], 2);
  ASSERT_EQ(result.natms_per_type[1], 2);

  ASSERT_EQ(result.masses_per_type[0], 63.546000);
  ASSERT_EQ(result.masses_per_type[1], 1.007930);

  ASSERT_EQ(result.atom_data.size(), 4);

  ASSERT_EQ(result.atom_data[0].symbol, "Cu");
  ASSERT_DOUBLE_EQ(result.atom_data[0].x, 0.63940000000000108);
  ASSERT_DOUBLE_EQ(result.atom_data[0].y, 0.90450000000000019);
  ASSERT_DOUBLE_EQ(result.atom_data[0].z, 6.97529999999999539);
  ASSERT_EQ(result.atom_data[0].is_fixed, true);
  ASSERT_EQ(result.atom_data[0].atom_id, 0);

  ASSERT_EQ(result.atom_data[1].symbol, "Cu");
  ASSERT_DOUBLE_EQ(result.atom_data[1].x, 3.19699999999999873);
  ASSERT_DOUBLE_EQ(result.atom_data[1].y, 0.90450000000000019);
  ASSERT_DOUBLE_EQ(result.atom_data[1].z, 6.97529999999999539);
  ASSERT_EQ(result.atom_data[1].is_fixed, true);
  ASSERT_EQ(result.atom_data[1].atom_id, 1);

  ASSERT_EQ(result.atom_data[2].symbol, "H");
  ASSERT_DOUBLE_EQ(result.atom_data[2].x, 8.68229999999999968);
  ASSERT_DOUBLE_EQ(result.atom_data[2].y, 9.94699999999999740);
  ASSERT_DOUBLE_EQ(result.atom_data[2].z, 11.73299999999999343);
  ASSERT_EQ(result.atom_data[2].is_fixed, false);
  ASSERT_EQ(result.atom_data[2].atom_id, 2);

  ASSERT_EQ(result.atom_data[3].symbol, "H");
  ASSERT_DOUBLE_EQ(result.atom_data[3].x, 7.94209999999999550);
  ASSERT_DOUBLE_EQ(result.atom_data[3].y, 9.94699999999999740);
  ASSERT_DOUBLE_EQ(result.atom_data[3].z, 11.73299999999999343);
  ASSERT_EQ(result.atom_data[3].is_fixed, false);
  ASSERT_EQ(result.atom_data[3].atom_id, 3);
}

TEST(ConFrameTest, CreateSingleCon_MultiFile) {
  // The actual lines of the multi con file.
  std::vector<std::string> a_fconts = {
      "Random Number Seed", "Time", "15.345600\t21.702000\t100.000000",
      "90.000000\t90.000000\t90.000000", "0 0", "218 0 1", "2", "2 2",
      "63.546000 1.007930", "Cu", "Coordinates of Component 1",
      "0.63940000000000108    0.90450000000000019    6.97529999999999539 1    "
      "0",
      "3.19699999999999873    0.90450000000000019    6.97529999999999539 1    "
      "1",
      "H", "Coordinates of Component 2",
      "8.68229999999999968    9.94699999999999740   11.73299999999999343 0  2",
      "7.94209999999999550    9.94699999999999740   11.73299999999999343 0  3",
      // Starting of the second con
      "Random Number Seed", "Time", "15.345600\t21.702000\t100.000000",
      "90.000000\t90.000000\t90.000000", "0 0", "218 0 1", "2", "2 2",
      "63.546000 1.007930", "Cu", "Coordinates of Component 1",
      "0.63940000000000108    0.90450000000000019    6.97529999999999539 1    "
      "0",
      "3.19699999999999873    0.90450000000000019    6.97529999999999539 1    "
      "1",
      "H", "Coordinates of Component 2",
      "8.85495714285713653    9.94699999999999740   11.16538571428571380 0  2",
      "7.76944285714285154    9.94699999999999740   11.16538571428571380 0  3"};

  // Call the function under test.
  ConFrame result = yodecon::create_single_con(a_fconts);
  // Check the resulting ConFrame object against expected values.
  ASSERT_EQ(result.prebox_header[0], "Random Number Seed");
  ASSERT_EQ(result.prebox_header[1], "Time");

  ASSERT_EQ(result.boxl[0], 15.345600);
  ASSERT_EQ(result.boxl[1], 21.702000);
  ASSERT_EQ(result.boxl[2], 100.000000);

  ASSERT_EQ(result.angles[0], 90.000000);
  ASSERT_EQ(result.angles[1], 90.000000);
  ASSERT_EQ(result.angles[2], 90.000000);

  ASSERT_EQ(result.natm_types, 2);
  ASSERT_EQ(result.natms_per_type[0], 2);
  ASSERT_EQ(result.natms_per_type[1], 2);

  ASSERT_EQ(result.masses_per_type[0], 63.546000);
  ASSERT_EQ(result.masses_per_type[1], 1.007930);

  ASSERT_EQ(result.atom_data.size(), 4);

  ASSERT_EQ(result.atom_data[0].symbol, "Cu");
  ASSERT_DOUBLE_EQ(result.atom_data[0].x, 0.63940000000000108);
  ASSERT_DOUBLE_EQ(result.atom_data[0].y, 0.90450000000000019);
  ASSERT_DOUBLE_EQ(result.atom_data[0].z, 6.97529999999999539);
  ASSERT_EQ(result.atom_data[0].is_fixed, true);
  ASSERT_EQ(result.atom_data[0].atom_id, 0);

  ASSERT_EQ(result.atom_data[1].symbol, "Cu");
  ASSERT_DOUBLE_EQ(result.atom_data[1].x, 3.19699999999999873);
  ASSERT_DOUBLE_EQ(result.atom_data[1].y, 0.90450000000000019);
  ASSERT_DOUBLE_EQ(result.atom_data[1].z, 6.97529999999999539);
  ASSERT_EQ(result.atom_data[1].is_fixed, true);
  ASSERT_EQ(result.atom_data[1].atom_id, 1);

  ASSERT_EQ(result.atom_data[2].symbol, "H");
  ASSERT_DOUBLE_EQ(result.atom_data[2].x, 8.68229999999999968);
  ASSERT_DOUBLE_EQ(result.atom_data[2].y, 9.94699999999999740);
  ASSERT_DOUBLE_EQ(result.atom_data[2].z, 11.73299999999999343);
  ASSERT_EQ(result.atom_data[2].is_fixed, false);
  ASSERT_EQ(result.atom_data[2].atom_id, 2);

  ASSERT_EQ(result.atom_data[3].symbol, "H");
  ASSERT_DOUBLE_EQ(result.atom_data[3].x, 7.94209999999999550);
  ASSERT_DOUBLE_EQ(result.atom_data[3].y, 9.94699999999999740);
  ASSERT_DOUBLE_EQ(result.atom_data[3].z, 11.73299999999999343);
  ASSERT_EQ(result.atom_data[3].is_fixed, false);
  ASSERT_EQ(result.atom_data[3].atom_id, 3);
}

int main(int argc, char **argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
